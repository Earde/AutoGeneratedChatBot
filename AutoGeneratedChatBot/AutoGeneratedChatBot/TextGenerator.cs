using System;
using System.Collections.Generic;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Types.Enums;
using Telegram.Bot.Types;

namespace AutoGeneratedChatBot
{
    class markov
    {
        public markov(string w)
        {
            word = w;
            count = 1;
        }
        public string word { get; set; }
        public int count { get; set; }
    }

    class chain
    {
        public chain(string w)
        {
            word = w;
            count = 1;
            markovs = new List<markov>();
        }
        public string word { get; set; }
        public int count { get; set; }
        public List<markov> markovs;
    }

    class TextGenerator
    {
        private static readonly TelegramBotClient bot = new TelegramBotClient("782389542:AAG8dI6JEbs-7exXG1fMpE02iJmyobgHWeo");
        private static List<chain> chainList = new List<chain>();
        private static List<chain> chainListStart = new List<chain>();
        private static Random rand = new Random();
        private static Int64 chatID = -1001401117617;
        private static int messageCounter = 0;
        private static int messageRandom = rand.Next(40, 60);
        private static User me;
        private static bool running = false;

        public TextGenerator()
        {
            me = bot.GetMeAsync().Result;
            Console.Title = me.Username;
            bot.OnMessage += BotOnMessageReceived;
        }

        public void Run()
        {
            if (!running)
            {
                var start = bot.SendTextMessageAsync(chatID, "Guess who's back? Fucking " + me.FirstName + " is back bitches.\r\nType /help for all the shit I can do.").Result;
                bot.StartReceiving();
                Console.WriteLine($"Start listening for @{me.Username}");
                running = true;
            }
        }

        public void Stop()
        {
            if (running)
            {
                var end = bot.SendTextMessageAsync(chatID, "RIP " + me.FirstName).Result;
                bot.StopReceiving();
                Console.WriteLine($"Stop listening for @{me.Username}");
                running = false;
            }
        }

        private static int GetStartIndex(List<chain> tempChain)
        {
            int totalCount = 0;
            foreach (chain c in tempChain)
            {
                totalCount += c.count;
            }
            int countRandom = rand.Next(1, totalCount + 1);
            int count = 0;
            int index = 0;
            foreach (chain c in tempChain)
            {
                count += c.count;
                if (count >= countRandom)
                {
                    break;
                }
                index++;
            }
            return index;
        }

        private static string GetNextWord(List<chain> tempChain, int index)
        {
            int totalCount = 0;
            foreach (markov m in tempChain[index].markovs)
            {
                totalCount += m.count;
            }
            int countRandom = rand.Next(1, totalCount + 1);
            int count = 0;
            foreach (markov m in tempChain[index].markovs)
            {
                count += m.count;
                if (count >= countRandom)
                {
                    return m.word;
                }
            }
            return ".";
        }

        private static string GetSentence(bool longSentence)
        {
            string sentence = "";
            int chainListIndex = GetStartIndex(chainListStart);
            string startWord = chainListStart[chainListIndex].word;
            string secondWord = GetNextWord(chainListStart, chainListIndex);
            sentence += startWord + " ";
            if (!secondWord.Equals("."))
            {
                sentence += secondWord + " ";
                int index = 0;
                foreach (chain c in chainList)
                {
                    if (c.word.Equals(secondWord))
                    {
                        chainListIndex = index;
                        break;
                    }
                    index++;
                }
                for (int i = 0; i < 250; i++)
                {
                    string nextWord = GetNextWord(chainList, chainListIndex);
                    if (nextWord.Equals("."))
                    {
                        return sentence.Remove(sentence.Length - 1, 1);
                    }
                    else
                    {
                        sentence += nextWord + " ";
                    }
                    index = 0;
                    bool found = false;
                    foreach (chain c in chainList)
                    {
                        if (c.word.Equals(nextWord))
                        {
                            chainListIndex = index;
                            found = true;
                            break;
                        }
                        index++;
                    }
                    if (!found)
                    {
                        return sentence.Remove(sentence.Length - 1, 1);
                    }
                }
            }
            return sentence.Remove(sentence.Length - 1, 1);
        }

        private static void SendMessage()
        {
            if (chainList.Count > 1 && chainListStart.Count > 1)
            {
                var send = bot.SendTextMessageAsync(chatID, GetSentence(false)).Result;
            }
        }

        private static void BotOnMessageReceived(object sender, MessageEventArgs messageEventArgs)
        {
            var message = messageEventArgs.Message;
            if (message == null || message.Type != MessageType.Text) return;
            if (message.Text == null || message.Text.Equals("")) return;
            if (message.Chat.Id != chatID || message.From.Id == 0) return;
            if(message.Text.StartsWith("/help"))
            {
                var send = bot.SendTextMessageAsync(chatID, "/talkbitch\r\n/stats\r\n/getwordinfo word\r\n").Result;
            }
            else if (message.Text.StartsWith("/talkbitch"))
            {
                for (int i = 0; i < 5; i++)
                {
                    SendMessage();
                }
            }
            else if (message.Text.StartsWith("/stats"))
            {
                var send = bot.SendTextMessageAsync(chatID, "Start words: " + chainListStart.Count + "\r\nContinuation words: " + chainList.Count).Result;
            }
            else if (message.Text.StartsWith("/getwordinfo"))
            {
                string[] words = message.Text.Split(' ');
                if (words.Length == 2)
                {
                    string sentence = "";
                    bool found = false;
                    foreach (chain c in chainListStart)
                    {
                        if (c.word.Equals(words[1]))
                        {
                            sentence += "Start word: " + words[1] + " { ";
                            foreach (markov m in c.markovs)
                            {
                                sentence += m.word + "(" + m.count + "), ";
                            }
                            sentence = sentence.Remove(sentence.Length - 2, 2);
                            sentence += " }\r\n";
                            found = true;
                            break;
                        }
                    }
                    foreach (chain c in chainList)
                    {
                        if (c.word.Equals(words[1]))
                        {
                            sentence += "Continuation word: " + words[1] + " { ";
                            foreach (markov m in c.markovs)
                            {
                                sentence += m.word + "(" + m.count + "), ";
                            }
                            sentence = sentence.Remove(sentence.Length - 2, 2);
                            sentence += " }";
                            found = true;
                            break;
                        }
                    }
                    if (found)
                    {
                        var send = bot.SendTextMessageAsync(chatID, sentence).Result;
                    }
                    else
                    {
                        var send = bot.SendTextMessageAsync(chatID, "Could't find " + words[1]).Result;
                    }
                }
                else
                {
                    var send = bot.SendTextMessageAsync(chatID, message.Text + " is WRONG!\r\nUse like this: /getwordinfo word\r\nYou stupid huh?").Result;
                }
            }
            else if (!message.Text.StartsWith("/"))
            {
                string trim = message.Text.Trim(new char[] { '.' });
                trim += " .";
                string[] words = trim.Split(' ');
                for (int i = 0; i < words.Length - 1; i++)
                {
                    List<chain> tempChain;
                    if (i == 0)
                    {
                        tempChain = chainListStart;
                    }
                    else
                    {
                        tempChain = chainList;
                    }
                    bool chainFound = false;
                    foreach (chain c in tempChain)
                    {
                        if (words[i].Equals(c.word))
                        {
                            bool markovFound = false;
                            foreach (markov m in c.markovs)
                            {
                                if (words[i + 1].Equals(m.word))
                                {
                                    m.count++;
                                    markovFound = true;
                                    break;
                                }
                            }
                            if (!markovFound)
                            {
                                c.markovs.Add(new markov(words[i + 1]));
                            }
                            chainFound = true;
                            c.count++;
                            break;
                        }
                    }
                    if (!chainFound)
                    {
                        tempChain.Add(new chain(words[i]));
                        i--;
                    }
                }
                messageCounter++;
            }

            if (messageCounter >= messageRandom)
            {
                messageCounter = 0;
                messageRandom = rand.Next(10, 20);
                SendMessage();
            }
        }
    }
}
