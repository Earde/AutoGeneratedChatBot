using System;
using System.Collections.Generic;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Types.Enums;

namespace AutoGeneratedChatBot
{
    class Program
    {
        private static readonly TelegramBotClient bot = new TelegramBotClient("782389542:AAG8dI6JEbs-7exXG1fMpE02iJmyobgHWeo");
        private static List<chain> chainList = new List<chain>();
        private static Random rand = new Random();

        static void Main(string[] args)
        {
            var me = bot.GetMeAsync().Result;
            Console.Title = me.Username;
            bot.OnMessage += BotOnMessageReceived;
            //var start = bot.SendTextMessageAsync(1, "Starting chatbot").Result;
            bot.StartReceiving();
            Console.WriteLine($"Start listening for @{me.Username}");
            Console.ReadLine();
            //SendMessage();
            bot.StopReceiving();
        }

        private static string GetNextWord(string word, int index)
        {
            int totalCount = 0;
            foreach (markov m in chainList[index].markovs)
            {
                totalCount += m.count;
            }
            int count = 0;
            int countRandom = rand.Next(0, totalCount);
            foreach (markov m in chainList[index].markovs)
            {
                count += m.count;
                if (m.count >= countRandom)
                {
                    return m.word;
                }
            }
            return "";
        }

        private static string GetSentence()
        {
            string sentence = "";
            int chainListIndex = rand.Next(0, chainList.Count);
            string startWord = chainList[chainListIndex].word;
            sentence += startWord + " ";
            for (int i = 0; i < 50; i++)
            {
                startWord = GetNextWord(startWord, chainListIndex);
                if (startWord.Equals(""))
                {
                    return sentence;
                } else
                {
                    sentence += startWord + " ";
                }
                int index = 0;
                bool found = false;
                foreach (chain c in chainList)
                {
                    if (c.word.Equals(startWord))
                    {
                        chainListIndex = index;
                        found = true;
                        break;
                    }
                    index++;
                }
                if (!found)
                {
                    return sentence;
                }
            }
            return sentence;
        }

        private static void SendMessage()
        {
            var send = bot.SendTextMessageAsync(1, GetSentence()).Result;
        }

        private static void BotOnMessageReceived(object sender, MessageEventArgs messageEventArgs)
        {
            var message = messageEventArgs.Message;
            if (message == null || message.Type != MessageType.Text) return;
            if (!message.Text.StartsWith("/"))
            {
                Console.WriteLine(message.Chat.Id.ToString());
                string trim = message.Text.Trim(new char[] { ',', '.', '!', '?' });
                string[] words = trim.Split(' ');
                for (int i = 0; i < words.Length - 1; i++)
                {
                    bool chainFound = false;
                    foreach (chain c in chainList)
                    {
                        if (words[i].Equals(c.word))
                        {
                            bool markovFound = false;
                            foreach (markov m in c.markovs)
                            {
                                if (words[i+1].Equals(m.word))
                                {
                                    m.count++;
                                    markovFound = true;
                                    break;
                                }
                            }
                            if (!markovFound)
                            {
                                c.markovs.Add(new markov(words[i + 1]));
                            }
                            chainFound = true;
                            break;
                        }
                    }
                    if (!chainFound)
                    {
                        chainList.Add(new chain(words[i]));
                        i--;
                    }
                }
            }
        }
    }
}
