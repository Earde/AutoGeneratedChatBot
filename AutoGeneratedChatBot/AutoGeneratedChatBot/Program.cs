using System;
using System.Collections.Generic;
using Telegram.Bot;
using Telegram.Bot.Args;
using Telegram.Bot.Types.Enums;

namespace AutoGeneratedChatBot
{
    class Program
    {
        private static readonly TelegramBotClient bot = new TelegramBotClient("782389542:AAG8dI6JEbs-7exXG1fMpE02iJmyobgHWeo");
        private static List<chain> chainList = new List<chain>();
        private static List<chain> chainListStart = new List<chain>();
        private static Random rand = new Random();
        private static Int64 chatID = -1001401117617;
        private static int messageCounter = 0;
        private static int messageRandom = rand.Next(40, 60);

        static void Main(string[] args)
        {
            var me = bot.GetMeAsync().Result;
            Console.Title = me.Username;
            bot.OnMessage += BotOnMessageReceived;
            var start = bot.SendTextMessageAsync(chatID, "Starting chatbot").Result;
            bot.StartReceiving();
            Console.WriteLine($"Start listening for @{me.Username}");
            Console.ReadLine();
            bot.StopReceiving();
        }

        private static string GetNextWord(List<chain> tempChain, string word, int index)
        {
            int totalCount = 0;
            foreach (markov m in tempChain[index].markovs)
            {
                totalCount += m.count;
            }
            int countRandom = rand.Next(1, totalCount + 1);
            int count = 0;
            foreach (markov m in tempChain[index].markovs)
            {
                count += m.count;
                if (count >= countRandom)
                {
                    return m.word;
                }
            }
            return "";
        }

        private static string GetSentence()
        {
            string sentence = "";
            int chainListIndex = rand.Next(0, chainListStart.Count);
            string startWord = chainListStart[chainListIndex].word;
            sentence += startWord + " ";
            startWord = GetNextWord(chainListStart, startWord, chainListIndex);
            int index = 0;
            foreach (chain c in chainList)
            {
                if (c.word.Equals(startWord))
                {
                    chainListIndex = index;
                    break;
                }
                index++;
            }
            for (int i = 0; i < 50; i++)
            {
                startWord = GetNextWord(chainList, startWord, chainListIndex);
                if (startWord.Equals(""))
                {
                    return sentence.Remove(sentence.Length - 1, 1) + ".";
                } else
                {
                    sentence += startWord + " ";
                }
                index = 0;
                bool found = false;
                foreach (chain c in chainList)
                {
                    if (c.word.Equals(startWord))
                    {
                        chainListIndex = index;
                        found = true;
                        break;
                    }
                    index++;
                }
                if (!found)
                {
                    return sentence.Remove(sentence.Length - 1, 1) + ".";
                }
            }
            return sentence.Remove(sentence.Length - 1, 1) + ".";
        }

        private static void SendMessage()
        {
            var send = bot.SendTextMessageAsync(chatID, GetSentence()).Result;
        }

        private static void BotOnMessageReceived(object sender, MessageEventArgs messageEventArgs)
        {
            var message = messageEventArgs.Message;
            if (message == null || message.Type != MessageType.Text) return;
            if (!message.Text.StartsWith("/"))
            {
                string trim = message.Text.Trim(new char[] { ',', '.', '!', '?' });
                string[] words = trim.Split(' ');
                for (int i = 0; i < words.Length - 1; i++)
                {
                    List<chain> tempChain;
                    if (i == 0)
                    {
                        tempChain = chainListStart;
                    } else
                    {
                        tempChain = chainList;
                    }
                    bool chainFound = false;
                    foreach (chain c in tempChain)
                    {
                        if (words[i].Equals(c.word))
                        {
                            bool markovFound = false;
                            foreach (markov m in c.markovs)
                            {
                                if (words[i+1].Equals(m.word))
                                {
                                    m.count++;
                                    markovFound = true;
                                    break;
                                }
                            }
                            if (!markovFound)
                            {
                                c.markovs.Add(new markov(words[i + 1]));
                            }
                            chainFound = true;
                            break;
                        }
                    }
                    if (!chainFound)
                    {
                        tempChain.Add(new chain(words[i]));
                        i--;
                    }
                }
                messageCounter++;
                if (messageCounter >= messageRandom)
                {
                    messageCounter = 0;
                    messageRandom = rand.Next(40, 60);
                    for (int i = 0; i < 5; i++)
                    {
                        SendMessage();
                    }
                }
            }
        }
    }
}
